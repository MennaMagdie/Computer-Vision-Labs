import numpy as np
import cv2

def compute_homography_matrix(pts1, pts2):
    """
    Compute the 3x3 homography matrix H such that: x' = Hx
    Inputs:
        pts1 - (N, 2) points from image 1
        pts2 - (N, 2) corresponding points from image 2
    Returns:
        H - (3, 3) homography matrix
    """
    assert pts1.shape == pts2.shape, "Input point arrays must have same shape"
    assert pts1.shape[0] >= 4, "At least 4 point correspondences required"

    n = pts1.shape[0]
    A = []

    for i in range(n):
        x, y = pts1[i][0], pts1[i][1]
        x_prime, y_prime = pts2[i][0], pts2[i][1]

        A.append([-x, -y, -1, 0, 0, 0, x * x_prime, y * x_prime, x_prime])
        A.append([0, 0, 0, -x, -y, -1, x * y_prime, y * y_prime, y_prime])

    A = np.asarray(A)
    U, S, Vt = np.linalg.svd(A)
    H = Vt[-1].reshape((3, 3))

    # Normalize H to make bottom-right element 1
    H = H / H[2, 2]
    return H

# ==== (Optional) Verification helper function ====
def warp_points(H, pts):
    """
    Warp points using a homography matrix
    """
    num_pts = pts.shape[0]
    pts_homogeneous = np.hstack((pts, np.ones((num_pts, 1))))
    warped = H @ pts_homogeneous.T
    warped = warped / warped[2]
    return warped[:2].T

# ======= Example of use =======
if __name__ == "__main__":
    # Example: load two matching images
    img1 = cv2.imread(r"C:\Users\User\PycharmProjects\pythonProject5\cv_cover.jpg")
    img2 = cv2.VideoCapture(r"C:\Users\User\PycharmProjects\pythonProject5\book.mov")
    ret, frame2 = img2.read()
    img2.release()

    # Convert to grayscale
    gray1 = cv2.cvtColor(img1, cv2.COLOR_BGR2GRAY)
    gray2 = cv2.cvtColor(frame2, cv2.COLOR_BGR2GRAY)

    # Detect correspondences
    sift = cv2.SIFT_create()
    kp1, des1 = sift.detectAndCompute(gray1, None)
    kp2, des2 = sift.detectAndCompute(gray2, None)

    bf = cv2.BFMatcher()
    matches = bf.knnMatch(des1, des2, k=2)

    good = []
    for m, n in matches:
        if m.distance < 0.75 * n.distance:
            good.append(m)

    good = sorted(good, key=lambda x: x.distance)[:50]

    pts1 = np.float32([kp1[m.queryIdx].pt for m in good])
    pts2 = np.float32([kp2[m.trainIdx].pt for m in good])

    # Compute Homography
    H = compute_homography_matrix(pts1, pts2)
    print("Homography matrix H:\n", H)

    # Optional: verify visually by warping points
    warped_pts1 = warp_points(H, pts1)
    error = np.linalg.norm(warped_pts1 - pts2, axis=1).mean()
    print("Mean projection error: {:.4f}".format(error))
