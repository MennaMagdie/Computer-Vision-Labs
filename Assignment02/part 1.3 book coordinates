import cv2
import numpy as np
import matplotlib.pyplot as plt

def get_book_corners_in_video(book_img_path, H):
    # Load the book image
    book_img = cv2.imread(book_img_path)
    h, w = book_img.shape[:2]

    # Define the four corners of the book in the image
    book_corners = np.array([
        [0, 0],         # Top-left
        [w - 1, 0],     # Top-right
        [w - 1, h - 1], # Bottom-right
        [0, h - 1]      # Bottom-left
    ], dtype=np.float32)

    # Convert to homogeneous coordinates
    ones = np.ones((4, 1))
    book_corners_hom = np.hstack([book_corners, ones])  # Shape: (4, 3)

    # Apply homography: p' = H * p
    mapped = H @ book_corners_hom.T  # Shape: (3, 4)
    mapped /= mapped[2]              # Normalize by last row

    book_corners_mapped = mapped[:2].T  # Final 2D points in video frame

    return book_corners, book_corners_mapped


def draw_book_corners_on_frame(frame, corners, color=(0, 255, 0)):
    # Draw polygon of transformed book
    corners = np.int32(corners)
    frame_with_box = frame.copy()
    cv2.polylines(frame_with_box, [corners], isClosed=True, color=color, thickness=2)
    return frame_with_box


# Example usage
if __name__ == "__main__":
    book_img_path = r"C:\Users\User\PycharmProjects\pythonProject5\cv_cover.jpg"
    video_path = r"C:\Users\User\PycharmProjects\pythonProject5\book.mov"

    # Step 1: Get homography matrix (assume you've computed H from part 1.2)
    # You can load from earlier step or dummy identity for now:
    from compute_homography import compute_homography_matrix

    # Get keypoints from both frames
    img1 = cv2.imread(book_img_path)
    cap = cv2.VideoCapture(video_path)
    ret, img2 = cap.read()
    cap.release()

    gray1 = cv2.cvtColor(img1, cv2.COLOR_BGR2GRAY)
    gray2 = cv2.cvtColor(img2, cv2.COLOR_BGR2GRAY)

    sift = cv2.SIFT_create()
    kp1, des1 = sift.detectAndCompute(gray1, None)
    kp2, des2 = sift.detectAndCompute(gray2, None)

    bf = cv2.BFMatcher()
    matches = bf.knnMatch(des1, des2, k=2)

    good = []
    for m, n in matches:
        if m.distance < 0.75 * n.distance:
            good.append(m)

    good = sorted(good, key=lambda x: x.distance)[:50]
    pts1 = np.float32([kp1[m.queryIdx].pt for m in good])
    pts2 = np.float32([kp2[m.trainIdx].pt for m in good])
    H = compute_homography_matrix(pts1, pts2)

    # Step 2: Get mapped book corners
    original_corners, mapped_corners = get_book_corners_in_video(book_img_path, H)

    # Step 3: Draw on video frame
    result_frame = draw_book_corners_on_frame(img2, mapped_corners)

    # Display
    plt.figure(figsize=(10, 6))
    plt.imshow(cv2.cvtColor(result_frame, cv2.COLOR_BGR2RGB))
    plt.title("Mapped Book Corners in Video Frame")
    plt.axis("off")
    plt.show()
